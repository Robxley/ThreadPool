
#ifndef THREAD_TASK_H
#define THREAD_TASK_H

#pragma once

#include <memory>
#include <condition_variable>
#include <future>
#include <functional>
#include <stdexcept>
#include <atomic>

//Friend function maker. To create a task from a lambda
template<class F, class... Args>
auto MakeTask(F&& f, Args&&... args)
{
	using return_type = typename std::invoke_result_t<F, Args...>;
	ThreadTask<return_type> task;
	task.set(std::forward<F>(f), std::forward<Args>(args)...);
	return task;
}

template<class F, class... Args>
auto MakeTastException(F&& f, Args&&... args)
{
	using return_type = typename std::invoke_result_t<F, Args...>;

	using return_eptr_type = std::pair<return_type, std::exception_ptr>;

	ThreadTask<return_eptr_type> task;

	auto task_with_exception = [](auto&&  ...args) 
	{
		std::exception_ptr eptr;
		return_type value;
		try
		{
			value = std::invoke(f, std::forward<decltype(args)> ...);
		}
		catch (...) { eptr = std::current_exception(); }
	};

	task.set(std::forward<F>(f), std::forward<Args>(args)...);
	return task;
}

template<class R = void>
class ThreadTask
{
	friend class ThreadPool;

private:
	//private constructeur
	ThreadTask(const ThreadTask&) = delete;
	ThreadTask& operator=(const ThreadTask&) = delete;

	std::future<R> future;		//Future generated by std::packaged_task
	std::function<void()> fct;  //Formatted function send to the thread pool
	
	//Generic type  (trick when result can be a 'void' type, specialization as empty structure)
	template <class R>	struct AnyType {
		R any;
	};
	template <> struct AnyType<void> {};

	AnyType<R> result;

public:

	ThreadTask() {};

	//Move constructor/operator
	ThreadTask(ThreadTask&& task)
	{
		this->fct = std::move(task.fct);
		this->future = std::move(task.future);
	}

	void operator=(ThreadTask&& task)
	{
		this->fct = std::move(task.fct);
		this->future = std::move(task.future);
	}

	template<class F, class... Args>
	ThreadTask(F&& f, Args&&... args) {
		set(std::forward<F>(f), std::forward<Args>(args)...);
	}


	template<class F, class... Args>
	void set(F&& f, Args&&... args)
	{
		using return_type = typename std::invoke_result_t<F, Args...>;
		static_assert(std::is_same_v<return_type, R>, "");

		auto task = std::make_shared< std::packaged_task<return_type()> >(
			std::bind(std::forward<F>(f), std::forward<Args>(args)...)
		);

		future = task->get_future();

		auto inprogress = std::make_shared<std::atomic_bool>(false);

		fct = [task, inprogress]() {
			if (bool test_val = false; inprogress->compare_exchange_strong(test_val, true))
				(*task)();
		};
	}

	R join()
	{
		fct();
		if constexpr (std::is_void_v<R>)
		{
			if (future.valid())
				future.get();
		}
		else
		{
			if (future.valid())
				result.any = future.get();
			return result.any;
		}
	}
};


#endif